#' Extract coordinates and address from a geocode locations list.
#'
#' \code{extract_from_geocode} extracts the exact address and coordinates from a list
#'    of locations generated with \code{\link[ggmap]{geocode}}.
#'
#' @param x list of geocoded locations generated by
#'    \code{ggmap::geocode(locations, output = "all", source = "google", nameType = "long")}
#' @return A data frame consisting of \code{address}, \code{lat} and \code{lon} of all locations.
#' @examples
#' \dontrun{
#' extract_from_geocode(ggmap::geocode(c("Paris, France", "London, UK", "Berlin, Germany"),
#' output = "all", source = "google", nameType = "long"))
#' }

extract_from_geocode <- function(x){
  lat <- x$results[[1]]$geometry$location$lat
  lon <- x$results[[1]]$geometry$location$lng
  address <- x$results[[1]]$formatted_address
  result <- dplyr::data_frame(location = address, lat = lat, lon = lon)
  return(result)
}


#' Scrape Events of Anti-Refugee Violence from "Mut gegen rechte Gewalt" Chronicle.
#'
#' This function is built only for one specific purpose:
#' Scraping the website \url{https://www.mut-gegen-rechte-gewalt.de/service/chronik-vorfaelle}
#' for all events a specified year (currently, 2015 and 2016). It retrieves the date, location,
#' bundesland, category, summary and source for each event and returns a data frame.
#'
#' @param years numeric vector of years for which to retrieve data from the chronicle.
#' @return A data frame of events as listed on the website, consisting of columns for date, location, bundesland,
#'    category, summary and source.
#' @examples
#' \dontrun{
#' chronicle <- read_chronicle(c(2015, 2016))
#' }
read_chronicle <- function(years) {
  ldply(years, read_chronicle_year, .progress = "text")
}

#' Scrape Events of Anti-Refugee Violence in a Given Year.
#'
#' This function scrapes all events in a specified year from the "Mut gegen rechte Gewalt" chronicle.
#' It retrieves the date, location,
#' bundesland, category, summary and source for each event and returns a data frame.
#'
#' @param year numeric value specifying the year for which to retrieve data from the chronicle.
#'    Currently, it only works with 2015 or 2016.
#' @return A data frame of events from a single year as listed in the chronicle,
#'    consisting of columns for date, location, bundesland, category, summary and source.
read_chronicle_year <- function(year) {
  if (!(year %in% c(2015, 2016))) stop("Data can only be retrieved for the years 2015 and 2016")
  base_page <- paste0("https://mut-gegen-rechte-gewalt.de/service/chronik-vorfaelle?&&field_date_value[value][year]=", year,"&page=0")
  chronicle <- read_html(base_page)

  last_page <- chronicle %>%
    html_node(".pager-last a") %>%
    html_attr("href") %>%
    stringi::stri_extract(regex = "page=[0-9]+") %>%
    gsub("page=", "", .) %>%
    as.numeric()

  print(paste0("Retrieving data for the year ", year, " from ", last_page + 1, " pages."))

  out <- ldply(0:last_page, read_chronicle_page, chronicle_year = year, .progress = "text")
  out
}


#' Scrape Individual Chronicle Page for Events of Anti-Refugee Violence in a Given Year.
#'
#' This function scrapes a single page from the "Mut gegen rechte Gewalt" chronicle.
#' It retrieves the date, location,
#' bundesland, category, summary and source for each event and returns a data frame.
#'
#' @param chronicle_year numeric value specifying the year for which to retrieve data from the chronicle.
#'    Currently, it only works with 2015 or 2016.
#' @param page_nr numeric value specifying chronicle page from which to retrieve data.
#' @return A data frame of events from a single chronicle page as listed in the chronicle,
#'    consisting of columns for date, location, bundesland, category, summary and source.
read_chronicle_page <- function(page_nr, chronicle_year) {
  violence <- read_html(paste0("https://mut-gegen-rechte-gewalt.de/service/chronik-vorfaelle?&&field_date_value[value][year]=", chronicle_year,"&page=", page_nr))

  ort <- violence %>%
    html_nodes(".field-name-field-city") %>%
    html_text()

  bundesland <- violence %>%
    html_nodes(".field-name-field-bundesland") %>%
    html_text()

  quelle_raw <- violence %>%
    html_nodes(".node-chronik-eintrag")

  quelle <- sapply(quelle_raw, function(x){
    check <- try(html_nodes(x, ".field-name-field-source .field-item"))
    if (inherits(check, "try-error") |
        (length(check)==0)) { return(NA) }
    links <- html_nodes(check, "a") %>%
      html_attr("href")
    links <- paste(links, collapse = " \n ")
    return(links)
  })

  datum <- violence %>%
    html_nodes(".field-name-field-date") %>%
    html_text()

  kategorie <- violence %>%
    html_nodes(".field-name-field-art") %>%
    html_text()

  zusammenfassung <- violence %>%
    html_nodes(".field-type-text-with-summary") %>%
    html_text()

  result <- dplyr::data_frame(datum, ort, bundesland, kategorie, zusammenfassung, quelle) %>%
    mutate_all(funs(gsub("^\\s+|\\s+$", "", .)))
}

#' Find the polygon in which a spatial point is located.
#'
#' Given a spatial polygon data frame and a data frame of point coordinates,
#' this function finds the subregion each point is located in, assigns its
#' respective ID and returns a data frame
#'
#' @param polygon_df polygon data frame in which the spatial points are supposed to be located.
#' @param points_df  data frame of points, consisting at least of a pair of lat/lon variables
#'    as well as a unique ID column.
#' @param key character string naming the column of the spatial polygon data frame which uniquely identifies
#'    each subregion.
#' @param .progress name of the progress bar (from plyr) to use.
#'
#' @return A data frame of unique point IDs and the respective ID for the subregion they are located in.
check_polygons <- function(polygon_df, points_df, key, .progress = "text") {
  num_districts <- unique(as.character(polygon_df@data[[key]])) # only works with map data from Geodatenzentrum
  result <- plyr::ddply(points_df, c("id"), function(point){
    p <- sp::SpatialPoints(point[ , c("lon", "lat")], proj4string=CRS(proj4string(polygon_df)))
    x <- try(polygon_df[p,], silent=TRUE)
    loc <- ifelse(inherits(x, "try-error"), NA, as.character(x@data[[key]]))
    return(data_frame(community_id = loc))
  }, .progress = .progress)
  return(result)
}
